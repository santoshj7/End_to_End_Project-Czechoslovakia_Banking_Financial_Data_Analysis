CREATE DATABASE CZECH_BANK;
USE CZECH_BANK;

/* TABLE CREATION */

CREATE OR REPLACE TABLE DISTRICT (
    District_Code INT PRIMARY KEY,
    District_Name VARCHAR(100),
    Region VARCHAR(100),
    No_of_Inhabitants INT,
    No_of_Municipalities_with_Inhabitants_less_499 INT,
    No_of_Municipalities_with_Inhabitants_btw_500_to_1999 INT,
    No_of_Municipalities_with_Inhabitants_btw_2000_to_9999 INT,
    No_of_Municipalities_with_Inhabitants_greater_10000 INT,
    No_of_Cities INT,
    Ratio_of_Urban_Inhabitants FLOAT,
    Average_Salary INT,
    No_of_Entrepreneurs_per_1000_Inhabitants INT,
    No_of_Committed_Crime_2017 INT,
    No_of_Committed_Crime_2018 INT
);

CREATE OR REPLACE TABLE ACCOUNT (
    Account_id INT PRIMARY KEY,
    District_id INT,
    Frequency VARCHAR(40),
    Date DATE,
    Account_type VARCHAR(40),
    Card_Assigned VARCHAR(20),
    FOREIGN KEY (District_id) REFERENCES DISTRICT(District_Code)
);

CREATE OR REPLACE TABLE CLIENT (
    Client_id INT PRIMARY KEY,
    Sex VARCHAR(10),
    Birth_Date DATE,
    District_id INT,
    FOREIGN KEY (District_id) REFERENCES DISTRICT(District_Code)
);

CREATE OR REPLACE TABLE DISPOSITION (
    Disp_id INT PRIMARY KEY,
    Client_id INT,
    Account_id INT,
    Type VARCHAR(10),
    FOREIGN KEY (Client_id) REFERENCES CLIENT(Client_id),
    FOREIGN KEY (Account_id) REFERENCES ACCOUNT(Account_id)
);

CREATE OR REPLACE TABLE CARD (
    Card_id INT PRIMARY KEY,
    Disp_id INT,
    Type VARCHAR(20),
    Issued DATE,
    FOREIGN KEY (Disp_id) REFERENCES DISPOSITION(Disp_id)
);

CREATE OR REPLACE TABLE LOAN (
    Loan_id INT PRIMARY KEY,
    Account_id INT,
    Date DATE,
    Amount INT,
    Duration INT,
    Payments INT,
    Status VARCHAR(40),
    FOREIGN KEY (Account_id) REFERENCES ACCOUNT(Account_id)
);

CREATE OR REPLACE TABLE ORDER_LIST (
    Order_id INT PRIMARY KEY,
    Account_id INT,
    Bank_to VARCHAR(100),
    Account_to INT,
    Amount FLOAT,
    FOREIGN KEY (Account_id) REFERENCES ACCOUNT(Account_id)
);

CREATE OR REPLACE TABLE TRANSACTIONS (
    Trans_id INT PRIMARY KEY,
    Account_id INT,
    Date DATE,
    Type VARCHAR(30),
    Operation VARCHAR(50),
    Amount INT,
    Balance FLOAT,
    Purpose VARCHAR(50),
    Bank VARCHAR(50),
    Account_Partern_id INT,
    FOREIGN KEY (Account_id) REFERENCES ACCOUNT(Account_id)
);

----------------------------------------------------------------------------------------

/* S3 STORAGE INTEGRATION */

CREATE OR REPLACE STORAGE INTEGRATION S3_CZECH_BANK_INT
TYPE = EXTERNAL_STAGE
STORAGE_PROVIDER = S3
ENABLED = TRUE
STORAGE_AWS_ROLE_ARN = 'arn:aws:iam::211125340148:role/czechbankdatarole'
STORAGE_ALLOWED_LOCATIONS = ('s3://czechbankingdata/');

DESC INTEGRATION S3_CZECH_BANK_INT;

-- Now, update the Trust Relationship Policy in the AWS IAM role section with the STORAGE_AWS_IAM_USER_ARN that was created automatically for our Snowflake account in the above step.

-- Creating File Format which will be required during Stage creation.

CREATE OR REPLACE FILE FORMAT BANK_CSV_FF 
TYPE = 'csv' 
COMPRESSION = 'none' 
FIELD_DELIMITER = ','
FIELD_OPTIONALLY_ENCLOSED_BY = 'none'
SKIP_HEADER = 1 ; 

-- Creating an external (i.e.S3) stage that references the storage integration we created above.

CREATE OR REPLACE STAGE CZECH_BANK_STAGE
URL ='s3://czechbankingdata'
FILE_FORMAT = BANK_CSV_FF
STORAGE_INTEGRATION = S3_CZECH_BANK_INT;

SHOW STAGES;

LIST @CZECH_BANK_STAGE;

-- Creating multiple SNOWPIPES that recognize CSV data ingested from an external stage and copy that data into respective tables in Snowflake.
-- The AUTO_INGEST=true parameter specifies to read event notifications sent from an S3 bucket to an SQS queue when new data is ready to load.

CREATE OR REPLACE PIPE BANK_SNOWPIPE_DISTRICT 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.DISTRICT -- Snowflake database-Snowflake schema-Snowflake table
FROM '@CZECH_BANK_STAGE/DISTRICT/' -- S3 bucket subfolder name
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_ACCOUNT 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.ACCOUNT 
FROM '@CZECH_BANK_STAGE/ACCOUNT/' 
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_CLIENT 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.CLIENT
FROM '@CZECH_BANK_STAGE/CLIENT/' 
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_DISPOSITION 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.DISPOSITION
FROM '@CZECH_BANK_STAGE/DISP/' 
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_CARD 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.CARD
FROM '@CZECH_BANK_STAGE/CARD/' 
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_LOAN 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.LOAN
FROM '@CZECH_BANK_STAGE/LOAN/' 
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_ORDER 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.ORDER_LIST
FROM '@CZECH_BANK_STAGE/ORDER/' 
FILE_FORMAT = BANK_CSV_FF;

CREATE OR REPLACE PIPE BANK_SNOWPIPE_TRANSACTIONS 
AUTO_INGEST = TRUE AS
COPY INTO CZECH_BANK.PUBLIC.TRANSACTIONS
FROM '@CZECH_BANK_STAGE/TRNX/' 
FILE_FORMAT = BANK_CSV_FF;

SHOW PIPES;

-- Create an Event Notification in S3 bucket using 'Notification Channel arn' which is available in the above Snowpipes, to read event notifications sent from an S3 bucket to an SQS queue when new data is ready to load.

-- Using the code below, we can check if any new data is updated in our S3 bucket.

ALTER PIPE BANK_SNOWPIPE_DISTRICT REFRESH;
ALTER PIPE BANK_SNOWPIPE_ACCOUNT REFRESH;
ALTER PIPE BANK_SNOWPIPE_CLIENT REFRESH;
ALTER PIPE BANK_SNOWPIPE_DISPOSITION REFRESH;
ALTER PIPE BANK_SNOWPIPE_CARD REFRESH;
ALTER PIPE BANK_SNOWPIPE_LOAN REFRESH;
ALTER PIPE BANK_SNOWPIPE_ORDER REFRESH;
ALTER PIPE BANK_SNOWPIPE_TRANSACTIONS REFRESH;

SELECT COUNT(*) FROM DISTRICT;
SELECT COUNT(*) FROM ACCOUNT;
SELECT COUNT(*) FROM CLIENT;
SELECT COUNT(*) FROM DISPOSITION;
SELECT COUNT(*) FROM CARD;
SELECT COUNT(*) FROM LOAN;
SELECT COUNT(*) FROM ORDER_LIST;
SELECT COUNT(*) FROM TRANSACTIONS;

SELECT * FROM DISTRICT;
SELECT * FROM ACCOUNT;
SELECT * FROM CLIENT;
SELECT * FROM DISPOSITION;
SELECT * FROM CARD;
SELECT * FROM LOAN;
SELECT * FROM ORDER_LIST;
SELECT * FROM TRANSACTIONS;

---------------------------------------------------------------------------------------

/* DATA TRANSFORMATIONS */

-- Client wants to update the Date information in Transaction table as follows.
-- In the Transactions table whosoever transaction count is highest, sort it in descending order and change the year from 2024,2023,2022... as follows.
/* CONVERT 2021 TXN_YEAR TO 2024
   CONVERT 2020 TXN_YEAR TO 2023
   CONVERT 2019 TXN_YEAR TO 2022
   CONVERT 2018 TXN_YEAR TO 2021
   CONVERT 2017 TXN_YEAR TO 2019
   CONVERT 2016 TXN_YEAR TO 2020 */

SELECT YEAR(DATE) AS TXN_YEAR, COUNT(*) AS TOT_TXNS
FROM TRANSACTIONS
GROUP BY 1
ORDER BY 2 DESC;

-- Converting 2021 TXN_YEAR to 2024
UPDATE TRANSACTIONS
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2021;

-- Converting 2020 TXN_YEAR to 2023
UPDATE TRANSACTIONS
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2020;

-- Converting 2019 TXN_YEAR to 2022
UPDATE TRANSACTIONS
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2019;

-- Converting 2018 TXN_YEAR to 2021
UPDATE TRANSACTIONS
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2018;

-- Converting 2017 TXN_YEAR to 2019
UPDATE TRANSACTIONS
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2017;

-- Converting 2016 TXN_YEAR to 2020
UPDATE TRANSACTIONS
SET DATE = DATEADD(YEAR, 4, DATE)
WHERE YEAR(DATE) = 2016;

SELECT YEAR(DATE) AS TXN_YEAR, COUNT(*) AS TOT_TXNS
FROM TRANSACTIONS
GROUP BY 1
ORDER BY 2 DESC;

/* Result before and after updating the date
2021 - 314532  -->  2024 - 314532
2020 - 284409  -->  2023 - 284409
2019 - 196779  -->  2022 - 196779
2018 - 133022  -->  2021 - 133022
2017 - 91628   -->  2019 - 91628
2016 - 28205   -->  2020 - 28205 */

-- Client wants to update the NULL values for the attribute 'BANK' in the TRANSACTION table for the particular transaction year as follows.
-- In the Transactions table whosoever transaction count is highest (in the context of NULL values in the attribute BANK), sort it in descending order and change the NULL values in attribute 'BANK' for the particular transaction year in the respective order - 'Sky Bank', 'DBS Bank', 'Northern Bank', 'Southern Bank', 'ADB Bank'.

SELECT YEAR(DATE) AS TXN_YEAR, COUNT(*) AS TOT_TXNS
FROM TRANSACTIONS
WHERE BANK IS NULL
GROUP BY 1
ORDER BY 2 DESC;

-- From the result, as per requirement we need to change the null values as follows.
/* 2024 (226491) --> Sky Bank
   2023 (210877) --> DBS Bank
   2022 (0) --> No NULL values
   2021 (99074) --> Northern Bank
   2019 (68763) --> Southern Bank
   2020 (22512) --> ADB Bank */

UPDATE TRANSACTIONS
SET BANK = 'Sky Bank'
WHERE BANK IS NULL AND YEAR(DATE) = 2024;

UPDATE TRANSACTIONS
SET BANK = 'DBS Bank'
WHERE BANK IS NULL AND YEAR(DATE) = 2023;

UPDATE TRANSACTIONS
SET BANK = 'Northern Bank'
WHERE BANK IS NULL AND YEAR(DATE) = 2021;

UPDATE TRANSACTIONS
SET BANK = 'Southern Bank'
WHERE BANK IS NULL AND YEAR(DATE) = 2019;

UPDATE TRANSACTIONS
SET BANK = 'ADB Bank'
WHERE BANK IS NULL AND YEAR(DATE) = 2020;

SELECT * FROM TRANSACTIONS;

-- Client wants to update the Issued Date information in the Card table as follows.
-- In the CARD table whosoever issued card count is highest, sort it in descending order and change the year from 2024,2023,2022... as follows.
/* CONVERT 2021 TXN_YEAR TO 2024
   CONVERT 2020 TXN_YEAR TO 2023
   CONVERT 2019 TXN_YEAR TO 2022
   CONVERT 2018 TXN_YEAR TO 2021
   CONVERT 2017 TXN_YEAR TO 2019
   CONVERT 2016 TXN_YEAR TO 2020 */
   
SELECT * FROM CARD;
SELECT DISTINCT YEAR(ISSUED) FROM CARD;

SELECT YEAR(ISSUED), COUNT(*) AS TOT_CARD_ISSUED
FROM CARD
GROUP BY 1
ORDER BY 2 DESC;

UPDATE CARD
SET ISSUED = DATEADD(YEAR, 3, ISSUED)
WHERE YEAR(ISSUED) = 2021;

UPDATE CARD
SET ISSUED = DATEADD(YEAR, 3, ISSUED)
WHERE YEAR(ISSUED) = 2020;

UPDATE CARD
SET ISSUED = DATEADD(YEAR, 3, ISSUED)
WHERE YEAR(ISSUED) = 2019;

UPDATE CARD
SET ISSUED = DATEADD(YEAR, 3, ISSUED)
WHERE YEAR(ISSUED) = 2018;

UPDATE CARD
SET ISSUED = DATEADD(YEAR, 2, ISSUED)
WHERE YEAR(ISSUED) = 2017;

UPDATE CARD
SET ISSUED = DATEADD(YEAR, 4, ISSUED)
WHERE YEAR(ISSUED) = 2016;

SELECT YEAR(ISSUED), COUNT(*) AS TOT_CARD_ISSUED
FROM CARD
GROUP BY 1
ORDER BY 2 DESC;

/* Result before and after updating the issued date
2021 - 449  -->  2024 - 449
2020 - 242  -->  2023 - 242
2019 - 116  -->  2022 - 116
2018 - 63   -->  2021 - 63
2017 - 21   -->  2019 - 21
2016 - 1    -->  2020 - 1 */

-- Client wants to update the DATE attribute in the ACCOUNT table by adding two years to the current date.
SELECT * FROM ACCOUNT;
SELECT YEAR(DATE), COUNT(*) FROM ACCOUNT
GROUP BY 1
ORDER BY 1 DESC;

UPDATE ACCOUNT
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2020;

UPDATE ACCOUNT
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2019;

UPDATE ACCOUNT
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2018;

UPDATE ACCOUNT
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2017;

UPDATE ACCOUNT
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2016;

SELECT YEAR(DATE), COUNT(*) FROM ACCOUNT
GROUP BY 1
ORDER BY 1 DESC; 

/* Result before and after updating the date
2020 - 898   -->  2022 - 898
2019 - 1363  -->  2021 - 1363
2018 - 661   -->  2020 - 661
2017 - 439   -->  2019 - 439
2016 - 1139  -->  2018 - 1139 */

-- Client wants to update the DATE attribute in the LOAN table as follows.
/* CONVERT 2021 YEAR TO 2024
   CONVERT 2020 YEAR TO 2023
   CONVERT 2019 YEAR TO 2022
   CONVERT 2018 YEAR TO 2021
   CONVERT 2017 YEAR TO 2019
   CONVERT 2016 YEAR TO 2020 */
   
SELECT * FROM LOAN;

SELECT YEAR(DATE), COUNT(*) FROM LOAN
GROUP BY 1
ORDER BY 1 DESC;

SELECT * FROM LOAN
WHERE YEAR(DATE) = 2019;

UPDATE LOAN
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2021;

UPDATE LOAN
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2020;

UPDATE LOAN
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2019;

UPDATE LOAN
SET DATE = DATEADD(YEAR, 3, DATE)
WHERE YEAR(DATE) = 2018;

UPDATE LOAN
SET DATE = DATEADD(YEAR, 2, DATE)
WHERE YEAR(DATE) = 2017;

UPDATE LOAN
SET DATE = DATEADD(YEAR, 4, DATE)
WHERE YEAR(DATE) = 2016;

SELECT YEAR(DATE), COUNT(*) FROM LOAN
GROUP BY 1
ORDER BY 1 DESC;

/* Result before and after updating the date
2021 - 158  -->  2024 - 158
2020 - 196  -->  2023 - 196
2019 - 117  -->  2022 - 117
2018 - 90   -->  2021 - 90
2017 - 101  -->  2019 - 101
2016 - 20   -->  2020 - 20 */

-- Client wants to add the AGE column to the CLIENT table by subtracting the birth year and last transaction year. 

SELECT * FROM CLIENT;
SELECT MAX(DATE) FROM TRANSACTIONS;

ALTER TABLE CLIENT
ADD COLUMN AGE INT;

UPDATE CLIENT
SET AGE = DATEDIFF(YEAR, BIRTH_DATE, '2024-12-19');

--------------------------------------------------------------------------------------

/* Ad-Hoc ANALYSIS */

-- Clients Age range
SELECT MIN(AGE), MAX(AGE) FROM CLIENT;

-- Total count of MALE and FEMALE clients
SELECT 
SUM(CASE WHEN SEX = 'Male' THEN 1 END) AS TOT_MALE_CLIENTS, 
SUM(CASE WHEN SEX = 'Female' THEN 1 END) AS TOT_FEMALE_CLIETS
FROM CLIENT;

-- MALE and FEMALE client percentage
SELECT 
ROUND((SUM(CASE WHEN SEX = 'Male' THEN 1 END) / COUNT(*)) * 100, 2) AS MALE_CLIENT_PERC, 
ROUND((SUM(CASE WHEN SEX = 'Female' THEN 1 END) / COUNT(*)) * 100, 2) AS FEMALE_CLIENT_PERC
FROM CLIENT;

SELECT * FROM DISTRICT;
SELECT * FROM ACCOUNT;
SELECT * FROM CLIENT;
SELECT * FROM DISPOSITION;
SELECT * FROM CARD;
SELECT * FROM LOAN;
SELECT * FROM ORDER_LIST;
SELECT * FROM TRANSACTIONS;

CREATE OR REPLACE TABLE TRANSACTION_MASTER AS
SELECT C.CLIENT_ID, C.SEX AS GENDER, C.AGE, A.ACCOUNT_ID, A.ACCOUNT_TYPE, D.DISTRICT_CODE, D.DISTRICT_NAME, D.NO_OF_INHABITANTS AS POPULATION, D.NO_OF_CITIES, D.AVERAGE_SALARY, D.REGION, T.TRANS_ID, T.DATE AS TXN_DATE, T.TYPE, T.OPERATION, T.AMOUNT, T.BALANCE, T.PURPOSE, T.BANK, T.ACCOUNT_PARTERN_ID
FROM TRANSACTIONS AS T
INNER JOIN ACCOUNT AS A ON A.ACCOUNT_ID = T.ACCOUNT_ID
INNER JOIN DISTRICT AS D ON A.DISTRICT_ID = D.DISTRICT_CODE
INNER JOIN DISPOSITION AS DI ON DI.ACCOUNT_ID = T.ACCOUNT_ID
INNER JOIN CLIENT AS C ON DI.CLIENT_ID = C.CLIENT_ID;

SELECT * FROM TRANSACTION_MASTER;

SELECT COUNT(DISTINCT CLIENT_ID) FROM TRANSACTION_MASTER;
SELECT COUNT(DISTINCT ACCOUNT_ID) FROM TRANSACTION_MASTER;
SELECT COUNT(DISTINCT DISTRICT_CODE) FROM TRANSACTION_MASTER;

/* 1. WHAT IS THE DEMOGRAPHIC PROFILE OF THE BANK'S CLIENTS AND HOW DOES IT VARY ACROSS DISTRICTS? */

CREATE OR REPLACE TABLE DEMOGRAPHIC_DATA_KPI AS
SELECT C.DISTRICT_ID, D.DISTRICT_NAME, D.NO_OF_CITIES, D.NO_OF_INHABITANTS AS POPULATION, D.REGION, D.AVERAGE_SALARY,
AVG(C.AGE) AS AVG_AGE,
SUM(CASE WHEN SEX = 'Male' THEN 1 END) AS MALE_CLIENTS, 
SUM(CASE WHEN SEX = 'Female' THEN 1 END) AS FEMALE_CLIENTS,
COUNT(*) AS TOT_CLIENTS,
ROUND((MALE_CLIENTS / COUNT(*)) * 100, 2) AS MALE_CLIENT_PERC, 
ROUND((FEMALE_CLIENTS / COUNT(*)) * 100, 2) AS FEMALE_CLIENT_PERC, 
ROUND((MALE_CLIENTS/FEMALE_CLIENTS), 2) AS MALE_FEMALE_CLIENT_RATIO
FROM CLIENT AS C
INNER JOIN DISTRICT AS D ON C.DISTRICT_ID = D.DISTRICT_CODE
GROUP BY 1,2,3,4,5,6
ORDER BY 1;

SELECT * FROM DEMOGRAPHIC_DATA_KPI;

/* 2. HOW THE BANKS HAVE PERFORMED OVER THE YEARS. GIVE THEIR DETAILED ANALYSIS YEAR & MONTH-WISE. */

-- To get every month's latest transaction balance, assuming month-end transaction as 'Credit'. (given by client)

CREATE OR REPLACE TABLE ACC_LATEST_TXNS_WITH_BALANCE AS

WITH LATEST_TXN_INFO AS (
SELECT ACCOUNT_ID, YEAR(DATE) AS TXN_YEAR, MONTH(DATE) AS TXN_MONTH, 
MAX(DATE) AS LATEST_TXN_DATE
FROM TRANSACTIONS
GROUP BY 1,2,3
ORDER BY 1,2,3)

SELECT LTI.*, T.BALANCE
FROM TRANSACTIONS AS T
INNER JOIN LATEST_TXN_INFO AS LTI ON T.ACCOUNT_ID = LTI.ACCOUNT_ID AND T.DATE = LTI.LATEST_TXN_DATE
WHERE T.TYPE = 'Credit' -- This assumption is given by client, every month end txn data is 'credit'
ORDER BY T.ACCOUNT_ID, LTI.TXN_YEAR, LTI.TXN_MONTH;

SELECT * FROM ACC_LATEST_TXNS_WITH_BALANCE;

-- Finding key performance indicators for bank transactions.

CREATE OR REPLACE TABLE BANKING_KPI AS
SELECT ALTB.TXN_YEAR, ALTB.TXN_MONTH, T.BANK, A.ACCOUNT_TYPE,
COUNT(DISTINCT ALTB.ACCOUNT_ID) AS TOT_ACCOUNT,
COUNT(DISTINCT T.TRANS_ID) AS TOT_TXNS,
COUNT(CASE WHEN T.TYPE = 'Credit' THEN 1 END) AS DEPOSIT_COUNT,
COUNT(CASE WHEN T.TYPE = 'Withdrawal' THEN 1 END) AS WITHDRAWAL_COUNT,
SUM(ALTB.BALANCE) AS TOT_BALANCE,
ROUND((DEPOSIT_COUNT/TOT_TXNS)*100, 2) AS DEPOSIT_PERC,
ROUND((WITHDRAWAL_COUNT/TOT_TXNS)*100, 2) AS WITHDRAWAL_PERC,
NVL(TOT_BALANCE/TOT_ACCOUNT, 0) AS AVG_BALANCE, -- if the result is null, NVL will replace that null value with 0.
ROUND(TOT_TXNS/TOT_ACCOUNT, 0) AS TPA -- Transactions per account
FROM TRANSACTIONS AS T
INNER JOIN ACC_LATEST_TXNS_WITH_BALANCE AS ALTB ON T.ACCOUNT_ID = ALTB.ACCOUNT_ID
LEFT OUTER JOIN ACCOUNT AS A ON T.ACCOUNT_ID = A.ACCOUNT_ID
GROUP BY 1,2,3,4
ORDER BY 1,2,3,4;

SELECT * FROM BANKING_KPI;

SELECT TXN_YEAR, BANK, SUM(AVG_BALANCE) AS TOT_AVG_BALANCE
FROM BANKING_KPI
GROUP BY 1,2
ORDER BY TOT_AVG_BALANCE DESC;

/* PROFITABILITY:
-- Since no revenue information is available in this dataset, the client wants to determine the profitability for each bank using the average balance they maintain in a financial year(1st April - 31st March).
-- Profitability conditions:
1. If the average balance is greater than or equal to 5M, the bank earns 5% interest on its total balance for that year.
2. If the average balance is between 3M and 5M, the bank earns 3% interest on its total balance for that year.
3. If the average balance is between 1M and 3M, the bank earns 1% interest on its total balance for that year.
4. If the average balance is less than 1M, the bank earns no interest.

-- The currency used in this dataset is CZK. We need to find the profitability in USD using the following conversion rates:
    - 1 CZK = 0.046735 USD 
    - 1 CZK = 3.836706 INR */

-- Creating a financial year-based sorting
SELECT TXN_YEAR, TXN_MONTH, 
    CASE 
        WHEN TXN_MONTH >= 4 
            THEN CONCAT(TXN_YEAR, '-', TXN_YEAR + 1) 
        ELSE CONCAT(TXN_YEAR - 1, '-', TXN_YEAR)
    END AS FINANCIAL_YEAR,
    SUM(TOT_BALANCE) AS TOT_BALANCE, SUM(AVG_BALANCE) AS TOT_AVG_BALANCE
FROM BANKING_KPI
GROUP BY 1,2,3
ORDER BY 1,2;

-- Creating a profitability table based on conditions
CREATE OR REPLACE TABLE BANK_PROFITABILITY AS 
SELECT TXN_YEAR, BANK,
    CASE 
        WHEN TXN_MONTH >= 4 
            THEN CONCAT(TXN_YEAR, '-', TXN_YEAR + 1) 
        ELSE CONCAT(TXN_YEAR - 1, '-', TXN_YEAR)
    END AS FINANCIAL_YEAR,
    SUM(AVG_BALANCE) AS TOT_AVG_BALANCE_IN_CZK,
    SUM(TOT_BALANCE) AS TOT_BALANCE_IN_CZK, 
    (TOT_AVG_BALANCE_IN_CZK * 0.046735) AS TOT_AVG_BALANCE_IN_USD,
    (TOT_BALANCE_IN_CZK * 0.046735) AS TOT_BALANCE_IN_USD,
    CASE
        WHEN TOT_AVG_BALANCE_IN_USD >= 5000000 THEN 5
        WHEN TOT_AVG_BALANCE_IN_USD >=3000000 AND TOT_AVG_BALANCE_IN_USD < 5000000 THEN 3
        WHEN TOT_AVG_BALANCE_IN_USD >=1000000 AND TOT_AVG_BALANCE_IN_USD < 3000000 THEN 1
        ELSE 0
    END AS INTEREST_RATE_IN_PERC,
    CASE
        WHEN TOT_AVG_BALANCE_IN_USD >= 5000000 THEN (TOT_BALANCE_IN_USD * 0.05)
        WHEN TOT_AVG_BALANCE_IN_USD >=3000000 AND TOT_AVG_BALANCE_IN_USD < 5000000 THEN (TOT_BALANCE_IN_USD * 0.03)
        WHEN TOT_AVG_BALANCE_IN_USD >=1000000 AND TOT_AVG_BALANCE_IN_USD < 3000000 THEN (TOT_BALANCE_IN_USD * 0.01)
        ELSE 0
    END AS PROFIT_EARNED_IN_USD
    
FROM BANKING_KPI
GROUP BY 1,2,3
ORDER BY 1,2;

SELECT * FROM BANK_PROFITABILITY;

-- Banks count based on the interest they earned
SELECT INTEREST_RATE_IN_PERC, COUNT(INTEREST_RATE_IN_PERC) AS BANK_COUNT
FROM BANK_PROFITABILITY
GROUP BY 1
ORDER BY 1 DESC;

SELECT * FROM BANK_PROFITABILITY
WHERE INTEREST_RATE_IN_PERC = 0;

-- Banks performance based on their profit
SELECT TXN_YEAR, FINANCIAL_YEAR, BANK, SUM(PROFIT_EARNED_IN_USD) AS TOT_PROFIT
FROM BANK_PROFITABILITY
GROUP BY 1,2,3
ORDER BY 4 DESC;

SELECT TXN_YEAR, BANK, SUM(PROFIT_EARNED_IN_USD) AS TOT_PROFIT
FROM BANK_PROFITABILITY
GROUP BY 1,2
ORDER BY 3 DESC;

/* 3. WHAT ARE THE MOST COMMON TYPES OF ACCOUNTS AND HOW DO THEY DIFFER IN TERMS OF USAGE AND PROFITABILITY? */

SELECT ACCOUNT_TYPE, SUM(TOT_ACCOUNT) AS TOT_ACCOUNT, SUM(TOT_TXNS) AS TOT_TXNS, 
SUM(DEPOSIT_COUNT) AS DEPOSIT_COUNT, SUM(WITHDRAWAL_COUNT) AS WITHDRAWAL_COUNT, SUM(TOT_BALANCE) AS TOT_BALANCE, 
SUM(AVG_BALANCE) AS TOT_AVG_BALANCE,
FROM BANKING_KPI
GROUP BY 1
ORDER BY TOT_TXNS DESC, TOT_BALANCE DESC;

SELECT BANK, ACCOUNT_TYPE, SUM(TOT_ACCOUNT) AS TOT_ACCOUNT, SUM(TOT_TXNS) AS TOT_TXNS, 
SUM(DEPOSIT_COUNT) AS DEPOSIT_COUNT, SUM(WITHDRAWAL_COUNT) AS WITHDRAWAL_COUNT, SUM(TOT_BALANCE) AS TOT_BALANCE, 
SUM(AVG_BALANCE) AS TOT_AVG_BALANCE,
FROM BANKING_KPI
GROUP BY 1,2
ORDER BY TOT_TXNS DESC, TOT_BALANCE DESC;

SELECT TXN_YEAR, BANK, ACCOUNT_TYPE, SUM(TOT_ACCOUNT) AS TOT_ACCOUNT, SUM(TOT_TXNS) AS TOT_TXNS, 
SUM(DEPOSIT_COUNT) AS DEPOSIT_COUNT, SUM(WITHDRAWAL_COUNT) AS WITHDRAWAL_COUNT, SUM(TOT_BALANCE) AS TOT_BALANCE, 
SUM(AVG_BALANCE) AS TOT_AVG_BALANCE,
FROM BANKING_KPI
GROUP BY 1,2,3
ORDER BY TOT_TXNS DESC, TOT_BALANCE DESC;

/* 4. WHICH TYPES OF CARDS ARE MOST FREQUENTLY USED BY THE BANK'S CLIENTS AND WHAT IS THE OVERALL PROFITABILITY OF THE CREDIT CARD BUSINESS? */

SELECT * FROM TRANSACTIONS
WHERE OPERATION = 'Credit card withdrawal';

CREATE OR REPLACE TABLE CREDIT_CARD_TXNS AS

WITH CREDIT_CARD_INFO AS (
SELECT A.ACCOUNT_ID, CI.SEX AS GENDER, CI.AGE, A.ACCOUNT_TYPE, C.CARD_ID, C.ISSUED AS CARD_ISSUED_DATE, C.TYPE AS CARD_TYPE
FROM ACCOUNT AS A 
INNER JOIN DISPOSITION AS D ON A.ACCOUNT_ID = D.ACCOUNT_ID
INNER JOIN CARD AS C ON D.DISP_ID = C.DISP_ID 
INNER JOIN CLIENT AS CI ON CI.CLIENT_ID = D.CLIENT_ID)

SELECT T.TRANS_ID, CCI.*, T.bank, YEAR(T.date) AS TXN_YEAR, MONTH(T.DATE) AS TXN_MONTH, T.date AS TXN_DATE, T.amount AS TXN_AMOUNT, T.operation
FROM TRANSACTIONS AS T 
INNER JOIN CREDIT_CARD_INFO AS CCI ON T.ACCOUNT_ID = CCI.ACCOUNT_ID
WHERE OPERATION = 'Credit card withdrawal';

SELECT * FROM CREDIT_CARD_TXNS;

SELECT CARD_TYPE, COUNT(DISTINCT TRANS_ID) AS TOT_CARD_TXNS, SUM(TXN_AMOUNT) AS TOT_TXN_AMOUNT
FROM CREDIT_CARD_TXNS
GROUP BY 1
ORDER BY TOT_CARD_TXNS DESC, TOT_TXN_AMOUNT DESC;

SELECT BANK, CARD_TYPE, COUNT(DISTINCT TRANS_ID) AS TOT_CARD_TXNS, SUM(TXN_AMOUNT) AS TOT_TXN_AMOUNT
FROM CREDIT_CARD_TXNS
GROUP BY 1,2
ORDER BY TOT_CARD_TXNS DESC, TOT_TXN_AMOUNT DESC;

SELECT TXN_YEAR, BANK, CARD_TYPE, COUNT(DISTINCT TRANS_ID) AS TOT_CARD_TXNS, SUM(TXN_AMOUNT) AS TOT_TXN_AMOUNT
FROM CREDIT_CARD_TXNS
GROUP BY 1,2,3
ORDER BY TOT_CARD_TXNS DESC, TOT_TXN_AMOUNT DESC;

/* 5. WHAT IS THE BANK’S LOAN PORTFOLIO AND HOW DOES IT VARY ACROSS DIFFERENT PURPOSES AND CLIENT SEGMENTS? */

CREATE OR REPLACE TABLE LOAN_TXNS AS

WITH LOAN_PORTFOLIO AS (
SELECT C.CLIENT_ID, C.SEX, C.AGE, D.DISTRICT_NAME, D.NO_OF_INHABITANTS AS POPULATION, D.REGION,
A.ACCOUNT_ID, A.ACCOUNT_TYPE, L.LOAN_ID, L.DATE AS LOAN_TAKEN_DATE, 
L.AMOUNT AS LOAN_AMOUNT, L.DURATION, L.PAYMENTS AS EMI, L.STATUS
FROM LOAN AS L
INNER JOIN ACCOUNT AS A ON A.ACCOUNT_ID = L.ACCOUNT_ID
INNER JOIN DISTRICT AS D ON A.DISTRICT_ID = D.DISTRICT_CODE
INNER JOIN DISPOSITION AS DIS ON A.ACCOUNT_ID = DIS.ACCOUNT_ID
INNER JOIN CLIENT AS C ON DIS.CLIENT_ID = C.CLIENT_ID
WHERE TYPE = 'OWNER')

SELECT T.TRANS_ID, YEAR(T.DATE) AS TXN_YEAR, MONTH(T.DATE) AS TXN_MONTH, T.DATE AS TXN_DATE, LP.ACCOUNT_ID, LP.ACCOUNT_TYPE, T.TYPE AS TXN_TYPE, T.OPERATION, T.AMOUNT AS TXN_AMOUNT, T.PURPOSE, T.BANK, T.ACCOUNT_PARTERN_ID, LP.LOAN_ID, LP.LOAN_TAKEN_DATE, LP.LOAN_AMOUNT, LP.DURATION, LP.EMI, LP.STATUS, LP.CLIENT_ID, LP.SEX AS GENDER, LP.AGE, LP.DISTRICT_NAME, LP.POPULATION, LP.REGION
FROM LOAN_PORTFOLIO AS LP
LEFT OUTER JOIN TRANSACTIONS AS T ON T.ACCOUNT_ID = LP.ACCOUNT_ID AND T.AMOUNT = LP.EMI;

SELECT * FROM LOAN_TXNS;

SELECT YEAR(LOAN_TAKEN_DATE) AS YEAR, GENDER, ACCOUNT_TYPE, STATUS, COUNT(DISTINCT LOAN_ID) AS TOT_LOANS, SUM(DISTINCT LOAN_AMOUNT) AS TOT_LOAN_AMOUNT
FROM LOAN_TXNS
GROUP BY 1,2,3,4
ORDER BY TOT_LOAN_AMOUNT DESC;






   